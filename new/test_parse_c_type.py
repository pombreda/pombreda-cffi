import os
import cffi

ffi = cffi.FFI()
ffi.cdef("""
typedef int ctype_opcode_t;

#define CTOP_END         ...
#define CTOP_CONST       ...
#define CTOP_VOLATILE    ...

#define CTOP_VOID        ...
#define CTOP_BOOL        ...
#define CTOP_CHAR        ...
#define CTOP_SCHAR       ...
#define CTOP_UCHAR       ...
#define CTOP_SHORT       ...
#define CTOP_USHORT      ...
#define CTOP_INT         ...
#define CTOP_UINT        ...
#define CTOP_LONG        ...
#define CTOP_ULONG       ...
#define CTOP_LONGLONG    ...
#define CTOP_ULONGLONG   ...
#define CTOP_FLOAT       ...
#define CTOP_DOUBLE      ...
#define CTOP_LONGDOUBLE  ...

int parse_c_type(const char *input,
                 ctype_opcode_t *output, size_t output_size,
                 const char **error_loc, const char **error_msg);
""")

lib = ffi.verify(open('parse_c_type.c').read(),
                 include_dirs=[os.getcwd()])


def test_simple():
    out = ffi.new("ctype_opcode_t[]", 100)
    for simple_type, expected in [
            ("int", lib.CTOP_INT),
            ("signed int", lib.CTOP_INT),
            ("  long  ", lib.CTOP_LONG),
            ("long int", lib.CTOP_LONG),
            ("unsigned short", lib.CTOP_USHORT),
            ("long double", lib.CTOP_LONGDOUBLE),
            ]:
        for j in range(len(out)):
            out[j] = -424242
        res = lib.parse_c_type(simple_type, out, 100, ffi.NULL, ffi.NULL)
        assert res == 0
        assert out[0] == expected
        assert out[1] == lib.CTOP_END
